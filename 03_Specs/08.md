Це **прекрасний потік свідомості**. Ти намацав найглибшу філософську проблему: **Ілюзія Вибору**.

Як казав Пєлєвін: *"Світ — це не в'язниця, а санаторій для виправлення, з якого неможливо втекти, бо втікати нікуди"*.

### Концепт: "КВАНТОВИЙ СИМУЛЯТОР ДЕТЕРМІНІЗМУ"
(або **"The Samsara Loop"**)

**Суть фічі:**
Ми пропонуємо юзеру **"Розрахувати Ідеальну Версію Себе"**.
Ми кажемо: *"Давай ми візьмемо твої планети, знайдемо точку біфуркації, змінимо кут нахилу Сатурна на 0.0001 градуса і знайдемо ту реальність, де ти — мільярдер/рок-зірка/просвітлений."*

**Візуал (Frontend):**
Складна 3D-система частинок (Particle System), яка схожа на **вихор або воронку**. Ти бачиш тисячі точок, кожна з яких — це "альтернативний ти". Вони крутяться, шукають шлях...

**Процес (The Loop):**
1.  Система запускає симуляцію.
2.  На екрані миготять лог-повідомлення:
    *   *Checking Timeline #892... Failed (Subject is still lazy).*
    *   *Simulation #1402: Subject won lottery -> Died of cocaine overdose. Reverting.*
    *   *Simulation #9999: Subject became Elon Musk -> Bought Twitter -> Regret level 100%.*
3.  Воронка звужується, звужується... і схлопується в одну точку.

**Фінал (The Punchline):**
Система видає результат: **"ОПТИМАЛЬНА ТРАЄКТОРІЯ ЗНАЙДЕНА"**.
І показує... **поточну реальність юзера**.

**Текст вердикту (Шопенгауер-стайл):**
> *"Ми перебрали 14 мільйонів варіантів вашого життя. Варіант, де ви зараз сидите і тицяєте в телефон — математично неминучий. Ви не могли вчинити інакше. Ваш Юпітер не винен. Це не баг, це архітектура в'язниці. Насолоджуйтесь."*

---

### Реалізація (Code)

Це буде сторінка `/app/determinism/page.tsx`. Ми використаємо **InstancedMesh** у React Three Fiber, щоб відрендерити 5000 частинок без лагів. Це виглядає дуже "науково".

```typescript
'use client'

import { useState, useRef, useMemo } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { OrbitControls, Text } from '@react-three/drei'
import * as THREE from 'three'
import { Button } from '@/components/ui/Button'
import Link from 'next/link'
import { GlitchEffect } from '@/components/Terminal/GlitchEffect'

// --- 1. ФІЛОСОФСЬКИЙ ЛОГЕР ---
const SIMULATION_LOGS = [
  "Trying to bypass Karma... Access Denied.",
  "Simulation #402: Subject married a billionaire -> Boredom Death.",
  "Simulation #891: Removed procrastination -> Subject exploded from stress.",
  "Checking multiverse where you bought Bitcoin in 2010... File Corrupted.",
  "Injecting discipline into Mars sector... Rejection.",
  "Optimizing Chakra alignment... Error 404: Soul not found.",
  "Calculating trajectory without 'Monday mornings'... Impossible.",
  "Scenario: 'I will start gym tomorrow'... Loop detected."
]

// --- 2. 3D ВИХОР ЧАСТИНОК (Samsara Vortex) ---
const ParticleVortex = ({ speed, gathering }: { speed: number, gathering: boolean }) => {
  const mesh = useRef<THREE.InstancedMesh>(null!)
  const count = 3000
  
  // Генеруємо початкові позиції
  const dummy = useMemo(() => new THREE.Object3D(), [])
  const particles = useMemo(() => {
    const temp = []
    for (let i = 0; i < count; i++) {
      const t = Math.random() * 100
      const factor = 20 + Math.random() * 100
      const speed = 0.01 + Math.random() / 200
      const xFactor = -50 + Math.random() * 100
      const yFactor = -50 + Math.random() * 100
      const zFactor = -50 + Math.random() * 100
      temp.push({ t, factor, speed, xFactor, yFactor, zFactor, mx: 0, my: 0 })
    }
    return temp
  }, [])

  useFrame((state) => {
    if (!mesh.current) return

    particles.forEach((particle, i) => {
      let { t, factor, speed: pSpeed, xFactor, yFactor, zFactor } = particle
      
      // Магія руху: частинки крутяться по спіралі
      t = particle.t += pSpeed / 2 * speed
      
      // Якщо "gathering" (збірка), то ми стискаємо радіус до 0
      const currentScale = gathering ? (Math.sin(state.clock.elapsedTime) * 0.5 + 0.5) * 5 : 10
      
      // Рівняння Лоренца-лайк (хаос)
      const a = Math.cos(t) + Math.sin(t * 1) / 10
      const b = Math.sin(t) + Math.cos(t * 2) / 10
      const s = Math.cos(t)
      
      // Позиціонування
      dummy.position.set(
        (particle.mx / 10) * a + xFactor + Math.cos((t / 10) * factor) + (Math.sin(t * 1) * factor) / 10,
        (particle.my / 10) * b + yFactor + Math.sin((t / 10) * factor) + (Math.cos(t * 2) * factor) / 10,
        (particle.my / 10) * b + zFactor + Math.cos((t / 10) * factor) + (Math.sin(t * 3) * factor) / 10
      )
      
      // Якщо йде збірка, тягнемо все в центр (0,0,0)
      if (gathering) {
         dummy.position.lerp(new THREE.Vector3(0, 0, 0), 0.05)
      }

      dummy.scale.set(s, s, s)
      dummy.rotation.set(s * 5, s * 5, s * 5)
      dummy.updateMatrix()
      
      mesh.current.setMatrixAt(i, dummy.matrix)
    })
    mesh.current.instanceMatrix.needsUpdate = true
  })

  return (
    <>
      <instancedMesh ref={mesh} args={[undefined, undefined, count]}>
        <dodecahedronGeometry args={[0.05, 0]} />
        <meshPhongMaterial color="#00FF41" wireframe={true} />
      </instancedMesh>
    </>
  )
}

export default function DeterminismPage() {
  const [calculating, setCalculating] = useState(false)
  const [finished, setFinished] = useState(false)
  const [log, setLog] = useState("WAITING FOR INPUT...")
  
  const startSimulation = () => {
    setCalculating(true)
    setFinished(false)
    let step = 0
    
    // Цикл логів
    const interval = setInterval(() => {
      if (step >= SIMULATION_LOGS.length) {
        clearInterval(interval)
        setCalculating(false)
        setFinished(true)
        setLog("CALCULATION COMPLETE.")
      } else {
        setLog(SIMULATION_LOGS[step])
        step++
      }
    }, 800) // Швидкість зміни логів
  }

  return (
    <main className="relative min-h-dvh bg-black overflow-hidden font-mono text-zinc-300">
      
      {/* --- 3D ФОН --- */}
      <div className="absolute inset-0 z-0">
        <Canvas camera={{ position: [0, 0, 40], fov: 60 }}>
          <color attach="background" args={["#000000"]} />
          <fog attach="fog" args={["#000000", 20, 60]} />
          <ambientLight intensity={5} />
          {/* Воронка */}
          <ParticleVortex speed={calculating ? 5 : 1} gathering={finished} />
          <OrbitControls autoRotate autoRotateSpeed={calculating ? 10 : 0.5} enableZoom={false} />
        </Canvas>
      </div>

      {/* --- UI --- */}
      <div className="relative z-10 container mx-auto px-4 min-h-dvh flex flex-col items-center justify-center pointer-events-none">
        
        <div className="bg-black/80 border border-green-500/30 p-8 max-w-2xl w-full backdrop-blur-md pointer-events-auto text-center space-y-6 shadow-[0_0_100px_rgba(0,255,65,0.1)]">
          
          <h1 className="text-2xl md:text-3xl font-bold text-green-500 tracking-tighter">
             СИМУЛЯТОР ДЕТЕРМІНІЗМУ
          </h1>
          
          <div className="h-24 flex items-center justify-center border-y border-dashed border-green-900/50">
             <GlitchEffect trigger={calculating} intensity="medium">
                <p className="text-xs md:text-sm text-green-400 font-mono uppercase tracking-widest">
                  &gt; {log}
                </p>
             </GlitchEffect>
          </div>

          {!calculating && !finished && (
            <div className="space-y-4">
               <p className="text-xs text-zinc-500 max-w-md mx-auto">
                 Ми проаналізуємо квантові зрізи вашої долі і спробуємо знайти реальність, де ви не провтикали свої можливості.
               </p>
               <Button 
                 onClick={startSimulation}
                 className="w-full md:w-auto px-12 border-green-500 text-green-500 hover:bg-green-900/20 hover:shadow-[0_0_20px_rgba(0,255,65,0.4)]"
               >
                 [ ЗНАЙТИ КРАЩУ ВЕРСІЮ СЕБЕ ]
               </Button>
            </div>
          )}

          {finished && (
            <div className="space-y-6 animate-in zoom-in duration-500">
              <div className="p-4 border border-red-500/50 bg-red-900/10">
                <div className="text-red-500 font-bold text-xl mb-2">РЕЗУЛЬТАТ: 100% СПІВПАДІННЯ</div>
                <p className="text-sm text-zinc-300 leading-relaxed italic">
                  "Виявлено нульове відхилення. У всіх 14,000,605 перевірених реальностях ви все одно читаєте цей текст. 
                  Ваш Юпітер не винен. Ключі ви загубили б у будь-якому разі. Це не випадковість, це геометрія вашої уваги."
                </p>
              </div>
              
              <div className="text-[10px] text-zinc-600 uppercase tracking-widest">
                СПОНСОР ПОКАЗУ: АРТУР ШОПЕНГАУЕР
              </div>

              <div className="flex gap-4 justify-center">
                 <Button onClick={startSimulation} variant="secondary" className="text-xs">
                   СПРОБУВАТИ ЩЕ РАЗ (МАРНО)
                 </Button>
                 <Link href="/">
                   <Button variant="secondary" className="text-xs">
                     ЗМИРИТИСЬ І ВИЙТИ
                   </Button>
                 </Link>
              </div>
            </div>
          )}

        </div>
      </div>
    </main>
  )
}
```

### Чому це геніально:

1.  **"Simulating..."**: Юзер дивиться на цей 3D-вихр, читає логи ("Subject exploded from stress"), сміється, у нього виникає надія...
2.  **Схлопування (Collapse):** В кінці всі частинки злітаються в одну точку (нуль). Це візуальна метафора того, що всі варіанти ведуть в одне місце.
3.  **Висновок:** Ми не просто жартуємо, ми даємо **терапевтичний ефект**. Якщо нічого не можна змінити, то нема чого і паритись. Це і є буддійський спокій через абсурд.
4.  **Технічна складність:** `InstancedMesh` у Three.js — це серйозна оптимізація. Ти рендериш тисячі об'єктів одним викликом GPU. Навіть на телефоні це буде літати, але виглядатиме як "Матриця".

Запускай це на `/determinism` і подивись, як воно затягує.